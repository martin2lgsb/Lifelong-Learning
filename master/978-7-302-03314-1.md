# 数据结构题集（C语言版）

### 第1章 绪论

1. 简述下列术语

   + 数据：是对客观事物的符号表示。在计算机科学中是指所有能输入到计算机中，并被计算机程序处理的符号的总称。
   + 数据元素：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。
   + 数据对象：是性质相同的数据元素的集合，是数据的一个子集。
   + 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。
   + 存储结构：是数据结构在计算机中的表示。
   + 数据类型：是一个值的集合和定义在这个值集上的一组操作的总称。
   + 抽象数据类型：是指一个数学模型以及定义在该模型上的一组操作。是对一般数据类型的扩展。

2. 试描述数据结构和抽象数据类型的概念与程序设计语言中数据类型概念的区别。

   解：抽象数据类型包含一般数据类型的概念，但含义比一般数据类型更广，更抽象。一般数据类型由具体语言系统内部定义，直接提供给编程者定义用户数据，因此称他们为预定义数据类型。抽象数据类型通常由编程者定义，包括定义它所使用的数据和在这些数据上所进行的操作。在定义抽象数据类型中的数据部分和操作部分时，要求只定义到数据的逻辑结构和操作说明，不考虑数据的储存结构和操作的具体实现，这样抽象层次更高，更能为其他用户提供良好的使用接口。

3. 设有数据结构 $(D, R)$ ，其中

   $$D={d1, d2, d3, d4}, R={r}, r={(d1, d2), (d2,d3), (d3, d4)}$$ 试按图论中图的画法管理画出其逻辑结构图。

   ```mermaid
   graph LR
   	d1((d1)) --> d2((d2))
   	d2((d2)) --> d3((d3))
   	d3((d3)) --> d4((d4))
   ```

4. 试仿造三元组的抽象数据类型分别写出抽象数据类型复数和有理数的定义（有理数是分子、分母均为自然数且分母部位零的分数）

   三元组的抽象数据类型：

   ADT Triplet {

   ​	数据对象：D = {e1, e2, e3 | e1, e2, e3 属于 Elemset(定义了关系的某个集合)}

   ​	数据关系：R1 = {<e1, e2> | <e2, e3>}

   ​	基本操作：

   ​	—InitTriplet(&T, v1, v2, v3)

   ​	— 初始条件：

   ​	— 操作结果：用 e 值取代三元组第 i 个元素



   ​	—DestoryTriplet(&T)

   ​	— 初始条件：三元组 T 已经存在。

   ​	— 操作结果：销毁三元组 T 。



   ​	—Get(T, i, &e)

   ​	— 初始条件：三元组 T 已经存在，1 <= i <= 3。

   ​	— 操作结果：用 e 返回三元组 T 的第 i 个元素。



   ​	—Put(&T, i, e)

   ​	— 初始条件：三元组 T 已经存在，1 <= i <= 3。

   ​	— 操作结果：用 e 值取代三元组 T 的第 i 个元素。



   ​	—IsAscending(T)

   ​	— 初始条件：三元组 T 已经存在。

   ​	— 操作结果：如果三元组 T 的三个元素按生序排列，则返回 TRUE；否则返回 FALSE。



   ​	—IsDescending(T)

   ​	— 初始条件：三元组 T 已经存在。

   ​	— 操作结果：如果三元组 T 的三个元素按降序排列，则返回TRUE；否则返回 FALSE。



   ​	—Max(T, &e)

   ​	— 初始条件：三元组 T 已经存在。

   ​	— 操作结果：用 e 返回三元组 T 的最大值。



   ​	—Min(T, &e)

   ​	— 初始条件：三元组 T 已经存在。

   ​	— 操作结果：用 e 返回三元组 T 的最小值。

   } ADT Triplet

   解：

   ADT Complex {

   ​	数据对象：D = {r, i | r, i 为实数}

   ​	数据关系：R = {<r, i>}

   ​	基本操作：

   ​		InitComplex(&C, re, im)

   ​		操作结果：构造一个复数 C，其实部和虚部为 re 和 im。

   ​		DestoryComplex(&C)

   ​		操作结果：销毁复数 C。

   ​		Get(C, k, &e)

   ​		操作结果：用 e 返回复数 C 的第 k 元的值。

   ​		Put(&C, k, e)

   ​		操作结果：改变复数 C 的第 k 元的值为 e。

   ​		IsAscending(C)

   ​		操作结果：如果复数 C 的两个元素按照升序排列，则返回 1；否则返回 0。

   ​		IsDescending(C)

   ​		操作结果：如果复数 C 的两个元素按照降序排列，则返回 1；否则返回 0.

   ​		Max(C, &e)

   ​		操作结果：用 e 返回复数 C 的两个元素中值较大的一个。

   ​		Min(C, &e)

   ​		操作结果：用 e 返回复数 C 的两个元素中值较小的一个。

   } ADT Complex

   ADT RationalNumber {

   ​	数据对象： D = {s, m | s, m 为自然数，且m不为 0}

   ​	数据关系：R = {<s, m>}

   ​	基本操作：

   ​		InitRationalNumber(&R, s, m)

   ​			操作结果：构造一个有理数 R， 其分子和分母分别为 s 和 m。

   ​		DestoryRationalNumber(&R)

   ​			操作结果：销毁有理数 R。

   ​		Get(R, k, &e)

   ​			操作结果：用 e 返回有理数 R 的第 k 元的值。

   ​		Put(&R, k, e)

   ​			操作结果：改变有理数 R 的第 k 元的值为 e。

   ​		IsAscending(R)

   ​			操作结果：如果有理数 R 的两个元素按升序排列，则返回 1；否则返回 0.

   ​		IsDescending(R)

   ​			操作结果：如果有理数 R 的两个元素按降序排列，则返回 1；否则返回 0；

   ​		Max(R, &e)

   ​			操作结果：用 e 返回有理数 R 的两个元素中较大的一个。

   ​		Min(R, &e)

   ​			操作结果：用 e 返回有理数 R 的两个元素中较小的一个。

   } ADT RationalNumber

5. 试画出与下列程序段等价的框图。

   ```c
   product = 1; i = 1;
   while (i <= n) {
       product *= 1;
       i++;
   }
   ```

   ```c
   i = 0;
   do {
       i++;
   } while ((i != n) && (a[i] != x))
   ```

   ```c
   switch {
       case x < y: z = y - x; break;
       case x = y: z = abs(x * y); break;
       default: z = (x - y) / abs(x) * abs(y);
   }
   ```

   解：

   ```flow
   st=>start: Start
   e=>end: End
   op0=>operation: product *= 1; i++;
   cond=>condition: i <= n
   op1=>operation: product *= 1; i++;
   
   st->op0->cond
   cond(yes)->op1->cond
   cond(no)-->e
   ```

   ```flow
   st=>start: Start
   e=>end: End
   op0=>operation: i = 0;
   op1=>operation: i++;
   cond=>condition: (i != n) && (a[i] != x)
   
   st->op0->op1->cond
   cond(yes)->op1
   cond(no)->e
   ```

   ```flow
   st=>start: Start
   e=>end: End
   io1=>inputoutput: x, y
   cond1=>condition: x < y
   op1=>operation: z = y - x;
   cond2=>condition: x = y
   op2=>operation: z = abs(x * y);
   op3=>operation: z = (x - y) / abs(x) * abs(y);
   
   st->io1->cond1
   cond1(yes)->op1->e
   cond1(no)->cond2
   cond2(yes)->op2->e
   cond2(no)->e
   ```

6. 在程序设计中，常用下列三种不同的出错处理方式：

   1. 用 exit 语句种植执行并报告错误；
   2. 以函数的返回值区别正确返回或错误返回；
   3. 设置一个整型变量的函数参数以区别正确返回或某种错误返回；

   试讨论着三种方法个字的优缺点。

   解：

   1. exit 常用语异常错误处理，他可以强行中断程序的执行，返回操作系统。
   2. 以函数的返回值判断正确与否常用语子程序测试，便于实现程序的局部控制。
   3. 用整形函数进行错误处理的优点是可以给出错误类型，便于迅速确定错误。

7. 在程序设计中，可采用下列三种反方实现输出和输入：

   1. 通过 scanf 和 printf 语句；
   2. 通过函数的参数显式传递；
   3. 通过全局变量隐式传递；

   试讨论着三种方法的优缺点。

   解：

   1. 用 scanf 和 printf 直接进行殊途输出的好处是形象、直观，但缺点是需要对其进行格式控制，较为繁琐，如果出现错误，则会引起整个系统的崩溃。
   2. 通过函数的参数传递进行输入输出，便于实现信息的隐蔽，减少出错的可能。
   3. 通过全局变量的饮食传递进行输入输出最为方便，只需修改变量的值即可，但过多的全局变量使程序的维护较为困难。